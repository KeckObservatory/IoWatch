<h1>ws: a Node.js WebSocket library</h1><p><a href="https://www.npmjs.com/package/ws"><img src="https://img.shields.io/npm/v/ws.svg" alt="Version npm"></a>
<a href="https://travis-ci.org/websockets/ws"><img src="https://img.shields.io/travis/websockets/ws/master.svg" alt="Linux Build"></a>
<a href="https://ci.appveyor.com/project/lpinca/ws"><img src="https://ci.appveyor.com/api/projects/status/github/websockets/ws?branch=master&amp;svg=true" alt="Windows Build"></a>
<a href="https://coveralls.io/r/websockets/ws?branch=master"><img src="https://img.shields.io/coveralls/websockets/ws/master.svg" alt="Coverage Status"></a></p>
<p><code>ws</code> is a simple to use, blazing fast, and thoroughly tested WebSocket client
and server implementation.</p>
<p>Passes the quite extensive Autobahn test suite. See <a href="http://websockets.github.io/ws/">http://websockets.github.io/ws/</a>
for the full reports.</p>
<p><strong>Note</strong>: This module does not work in the browser. The client in the docs is a
reference to a back end with the role of a client in the WebSocket
communication. Browser clients must use the native
<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket"><code>WebSocket</code></a> object.</p>
<h2>Protocol support</h2><ul>
<li><strong>HyBi drafts 07-12</strong> (Use the option <code>protocolVersion: 8</code>)</li>
<li><strong>HyBi drafts 13-17</strong> (Current default, alternatively option <code>protocolVersion: 13</code>)</li>
</ul>
<h2>Installing</h2><pre><code>npm install --save ws
</code></pre><h3>Opt-in for performance and spec compliance</h3><p>There are 2 optional modules that can be installed along side with the <code>ws</code>
module. These modules are binary addons which improve certain operations.
Prebuilt binaries are available for the most popular platforms so you don&#39;t
necessarily need to have a C++ compiler installed on your machine.</p>
<ul>
<li><code>npm install --save-optional bufferutil</code>: Allows to efficiently perform
operations such as masking and unmasking the data payload of the WebSocket
frames.</li>
<li><code>npm install --save-optional utf-8-validate</code>: Allows to efficiently check
if a message contains valid UTF-8 as required by the spec.</li>
</ul>
<h2>API Docs</h2><p>See <a href="https://github.com/websockets/ws/blob/master/doc/ws.md"><code>/doc/ws.md</code></a>
for Node.js-like docs for the ws classes.</p>
<h2>WebSocket compression</h2><p><code>ws</code> supports the <a href="https://tools.ietf.org/html/rfc7692">permessage-deflate extension</a> which
enables the client and server to negotiate a compression algorithm and its
parameters, and then selectively apply it to the data payloads of each
WebSocket message.</p>
<p>The extension is enabled by default but adds a significant overhead in terms of
performance and memory comsumption. We suggest to use WebSocket compression
only if it is really needed.</p>
<p>To disable the extension you can set the <code>perMessageDeflate</code> option to <code>false</code>.
On the server:</p>
<pre><code class="language-js">const WebSocket = require(&#39;ws&#39;);

const wss = new WebSocket.Server({
  perMessageDeflate: false,
  port: 8080
});
</code></pre>
<p>On the client:</p>
<pre><code class="language-js">const WebSocket = require(&#39;ws&#39;);

const ws = new WebSocket(&#39;ws://www.host.com/path&#39;, {
  perMessageDeflate: false
});
</code></pre>
<h2>Usage examples</h2><h3>Sending and receiving text data</h3><pre><code class="language-js">const WebSocket = require(&#39;ws&#39;);

const ws = new WebSocket(&#39;ws://www.host.com/path&#39;);

ws.on(&#39;open&#39;, function open() {
  ws.send(&#39;something&#39;);
});

ws.on(&#39;message&#39;, function incoming(data, flags) {
  // flags.binary will be set if a binary data is received.
  // flags.masked will be set if the data was masked.
});
</code></pre>
<h3>Sending binary data</h3><pre><code class="language-js">const WebSocket = require(&#39;ws&#39;);

const ws = new WebSocket(&#39;ws://www.host.com/path&#39;);

ws.on(&#39;open&#39;, function open() {
  const array = new Float32Array(5);

  for (var i = 0; i &lt; array.length; ++i) {
    array[i] = i / 2;
  }

  ws.send(array);
});
</code></pre>
<h3>Server example</h3><pre><code class="language-js">const WebSocket = require(&#39;ws&#39;);

const wss = new WebSocket.Server({ port: 8080 });

wss.on(&#39;connection&#39;, function connection(ws) {
  ws.on(&#39;message&#39;, function incoming(message) {
    console.log(&#39;received: %s&#39;, message);
  });

  ws.send(&#39;something&#39;);
});
</code></pre>
<h3>Broadcast example</h3><pre><code class="language-js">const WebSocket = require(&#39;ws&#39;);

const wss = new WebSocket.Server({ port: 8080 });

// Broadcast to all.
wss.broadcast = function broadcast(data) {
  wss.clients.forEach(function each(client) {
    if (client.readyState === WebSocket.OPEN) {
      client.send(data);
    }
  });
};

wss.on(&#39;connection&#39;, function connection(ws) {
  ws.on(&#39;message&#39;, function incoming(data) {
    // Broadcast to everyone else.
    wss.clients.forEach(function each(client) {
      if (client !== ws &amp;&amp; client.readyState === WebSocket.OPEN) {
        client.send(data);
      }
    });
  });
});
</code></pre>
<h3>ExpressJS example</h3><pre><code class="language-js">const express = require(&#39;express&#39;);
const http = require(&#39;http&#39;);
const url = require(&#39;url&#39;);
const WebSocket = require(&#39;ws&#39;);

const app = express();

app.use(function (req, res) {
  res.send({ msg: &quot;hello&quot; });
});

const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

wss.on(&#39;connection&#39;, function connection(ws) {
  const location = url.parse(ws.upgradeReq.url, true);
  // You might use location.query.access_token to authenticate or share sessions
  // or ws.upgradeReq.headers.cookie (see http://stackoverflow.com/a/16395220/151312)

  ws.on(&#39;message&#39;, function incoming(message) {
    console.log(&#39;received: %s&#39;, message);
  });

  ws.send(&#39;something&#39;);
});

server.listen(8080, function listening() {
  console.log(&#39;Listening on %d&#39;, server.address().port);
});
</code></pre>
<h3>echo.websocket.org demo</h3><pre><code class="language-js">const WebSocket = require(&#39;ws&#39;);

const ws = new WebSocket(&#39;wss://echo.websocket.org/&#39;, {
  origin: &#39;https://websocket.org&#39;
});

ws.on(&#39;open&#39;, function open() {
  console.log(&#39;connected&#39;);
  ws.send(Date.now());
});

ws.on(&#39;close&#39;, function close() {
  console.log(&#39;disconnected&#39;);
});

ws.on(&#39;message&#39;, function incoming(data, flags) {
  console.log(`Roundtrip time: ${Date.now() - data} ms`, flags);

  setTimeout(function timeout() {
    ws.send(Date.now());
  }, 500);
});
</code></pre>
<h3>Other examples</h3><p>For a full example with a browser client communicating with a ws server, see the
examples folder.</p>
<p>Otherwise, see the test cases.</p>
<h2>Error handling best practices</h2><pre><code class="language-js">// If the WebSocket is closed before the following send is attempted
ws.send(&#39;something&#39;);

// Errors (both immediate and async write errors) can be detected in an optional
// callback. The callback is also the only way of being notified that data has
// actually been sent.
ws.send(&#39;something&#39;, function ack(error) {
  // If error is not defined, the send has been completed, otherwise the error
  // object will indicate what failed.
});

// Immediate errors can also be handled with `try...catch`, but **note** that
// since sends are inherently asynchronous, socket write failures will *not* be
// captured when this technique is used.
try { ws.send(&#39;something&#39;); }
catch (e) { /* handle error */ }
</code></pre>
<h2>Changelog</h2><p>We&#39;re using the GitHub <a href="https://github.com/websockets/ws/releases"><code>releases</code></a>
for changelog entries.</p>
<h2>License</h2><p><a href="LICENSE">MIT</a></p>
